param($S,$Q=$null,$i=$null,$D="master",[switch]$MultipleRS = $false, $OutputMessages = $true, $ReaderFunction = "NewDataReaderParser")

$ErrorActionPreference="stop";
#Save current location
push-location
#Change current location
set-location (Split-Path -Parent $MyInvocation.MyCommand.Definition )


$PERF = @{};
Function updatePerf($n,$v,$on = $false) {  

	if($PERF.ContainsKey($n)){
		if(!$on){
			$PERF[$n] = $v.ElapsedTicks
		}
	} else {
		$PERF.add($n,$v.ElapsedTicks);
	}


}


	try{

		. ".\readerResult.ps1"
		

	#Creating the connection 
		$ConnectionString = @(
			"Server=$($S)"
			"Database=$($D)"
			"Integrated Security=True"
		)

		if(!$Pooling){
			$ConnectionString += "Pooling=false"
		}
		
		$QueryResults 	= New-Object PSObject -Prop @{ results = @(); messages=@() };
		$Messages		= @(); #Represent the message and errors generated by t-sql..
		$ReaderParser = Invoke-Expression ". $ReaderFunction";
		
		$queryToRun=$Q;
		if(!$queryToRun){
			$queryToRun = (Get-Content $i) -join "`r`n";
		}
		
		if(!$queryToRun){
			throw "invalid query!"
		}
		
		try {
			$NewConex = New-Object System.Data.SqlClient.SqlConnection
			$NewConex.ConnectionString = $ConnectionString -Join ";" 
			$NewConex.Open()
			
			#Errors 11 to 16 will be treated as event, in order to allow query process fully (simulating ssms)
			$NewConex.FireInfoMessageEventOnUserErrors = $true;
			
			#Register Info Message event handler...
			$InfoMessageParams = @{Out=$OutputMessages; Events=@()};			
			$InfoMessageSubcriber = Register-ObjectEvent -InputObject $NewConex -EventName "InfoMessage"
			
			#Setup commands...
			$commandTSQL = $NewConex.CreateCommand()
			$commandTSQL.CommandText = $queryToRun;
			$commandTSQL.CommandTimeout = 0;
			
			#Execute and get results...
			$ContinueTheRead = $true;
			try {
				$ReaderParser.reader = $commandTSQL.ExecuteReader()
			} catch {
			
				#Check if base exception is SQL Exceptions...
				$Bex = $_.Exception.GetBaseException();
				
				if($Bex -is [System.Data.SqlClient.SqlException]){
					$QueryResults.messages += $Bex.Errors;
				}
				else {
					throw; #Was another error from .NET . Script must ends.
				}
				
			}
			

			if(!$ReaderParser.reader){
				$ReaderParser.hadNext = $false;
			}
					
			if( $ReaderParser.hadNext ){
				try {
					Measure-command {
						$QueryResults.results += $ReaderParser.GetNextResultSet();
					}
					
					write-host "Read count: " $ReaderParser.readCount;
				} catch {
					$Bex = $_.Exception.GetBaseException();
					
					if($Bex -is [System.Data.SqlClient.SqlException]){
						$QueryResults.messages += $Bex.Errors;
					}
					else {
						throw; #Was another error from .NET . Script must ends.
					}
					
				}
				
			} 
			
			#Process the event messages!
			

		} finally {
		
			#Message events.
			Get-Event | ? {$_.Sender.Equals($NewConex)} | %{
				$EventArguments = $_.SourceEventArgs -as [System.Data.SqlClient.SqlInfoMessageEventArgs];
				$QueryResults.messages += $EventArguments.Errors;
				Remove-Event -EventIdentifier $_.EventIdentifier;
			}
		
			if($NewConex -and !$MultipleRS){
				write-host "Disposing connection!"
				#$Newconex.Dispose()
			}
			
			if($InfoMessageSubcriber){
				Unregister-Event $InfoMessageSubcriber.Name;
			}
		
		}
		
	} finally {
		pop-location
	}


$PERF.GetEnumerator() | %{

	$PerfName = $_.Key;
	$M = $_.Value;
	
	
	write-host $PerfName ($M)


}
	
	